빈 설정 메타정보 항목
beanClassName : 빈 오브젝트 클래스 이름
parentName : 빈 메타정보를 상속받을 부모 BeanDefinition 이름
factoryBeanName: 팩토리 빈 이름
factoryMethodName : 다른 빈 또는 클래스의 메서드를 통해 빈 오브젝트를 생성하는 경우 메서드 이름
scope : 생명주기를 결정하는 스코프, 싱글톤 혹은 비싱글톤
lazyInit : 빈 오브젝트의 생성을 최대한 지연할 것인지 지정
dependsOn : 먼저 만들어져야 하는 빈을 지정할 수 있다. 빈 오브젝트의 생성 순서가 보장되어야 하는 경우 이용
autowireCandidate : 명시적인 설정이 없어도 미리 정해진 규칙을 가지고 자등올 DI 후보를 결졍하는 자동 와어어링 대상으로 포함시킬지 여부
primary : DI 대상후보가 여러 개가 발생하는 경우, 최종 선택의 우선권 부여
abstract : 메타정보 상속에만 사용할 추상 빈으로 만들지의 여부
autowireMode : 오토와이어링 전략
dependencyCheck : 프로퍼티 값 또는 레퍼런스가 모두 설정되어 있는지 검증하는 작업의 종류
initMethod : 빈이 생성되고 DI를 마친 뒤 실행할 초기화 메서드
destroyMethod : 빈의 생명주기가 다 되서 제거하기 전에 호출할 메서드
propertyValues : 프로퍼티의 이름과 설정 값 또는 레퍼런스, 수정자 메서드를 통한 DI 작업에서 사용
constructorArgumentValues : 생성자의 이름과 설정 값 또는 레퍼런스, 생성자를 통한 DI 작업에서 사용
annotationMetadata : 빈 클래스에 담긴 애노테이션과 그 애트리뷰트 값, 애노테이션을 이용하는 설정에서 활용

빈 등록 방법
1. XML <bean> 태그
    기본적으로 id와 class라는 두 개의 애트리뷰트가 필요하다.
    <bean>은 다른 빈의 <property>태그 안에 정의할 수도 있다.
    다른 빈의 설정 안에 정의되는 빈을 내부 빈(inner bean)이라고 하는데 아이디가 없으므로 다른 빈에서 참조할 수 없다.

2. 네임스페이스와 전용 태그
    pointcut과 같은 빈들은 핵심 로직을 담은 컴포넌트가 아니고 어플리케이션 컨텍스트가 활용하는 기술적인 설정 정보를 담고 있을 뿐이다.
    컨텍스트가 사용하는 설정정보를 담은 빈과 어플리케이션 3계층에 포함되는 어플리케이션 로직을 담은 빈이 동일하게 <bean>이라는 태그를 사용해서 만들어지기 때문에 구분이 잘 안되고 빈의 등록이 어떤 의도와 의미를 갖고 있는지 파악하기 어렵다.
    스프링은 이런 기술적인 설정과 기반 서비스를 빈으로 등록할 때를 위해 의미가 잘 드러나는 네임 스페이스와 태그를 가진 설정방법을 제공한다.
    <aop:pointcut id="mypointcut" expression"..."/>

3. 자동인식을 이용한 빈 등록: 스테레오타입 애노테이션과 빈 스캐너
    특정 어노테이션이 붙은 클래스를 자동으로 찾아서 빈 등록을 해주는 방식을 빈 스캐닝을 통한 자동인식 빈 등록 기능이라고 하고, 이런 스캐닝 작업을 담당하는 오브젝트를 빈 스캐너라고 한다.
    빈 스캐너에 내장된 디폴트 필터는 @Component 어노테이션 또는 @Component를 메타 어노테이션으로 가진 어노테이션이 부여된 클래스를 선택하도록 되어 있다.
    @Component를 포함해 디폴트 필터에 적용되는 어노테이션을 스프링에서 스테레오 어노테이션이라고 부른다.
    빈 스캐너는 기본적으로 클래스 이름을 빈의 ID로 사용한다. 정확히는 클래스 이름의 첫 글자만 소문자로 바꾼 것을 사용한다.
    빈의 이름을 클래스 이름과 다르게 지정해야 할 때가 있다. 이름이 같은 빈이 이미 존재하기 때문에 충돌을 피하기 위해서이거나, 좀 더 의미 있는 이름을 사용하고 싶을 때 @Component 디폴트 값을 이용해 빈 이름을 지정할 수 있다.
    빈의 개수가 많아지면 XML 문서를 보고 전체 어플리케이션의 구성을 간단히 파악하기 어렵다.
    누군가 책임을 지고 어플리케이션을 구성하는 빈과 의존관계, 설정 등을 통제하고 관리하는 데는 XML이 유리하다.
    빈 스캔에 의해 자동등록되는 빈은 XML처럼 상세한 메타정보 항목을 지정할 수 없다. 클래스당 한 개 이상의 빈을 등록할 수 없다는 제한이 있다.
    그러나 대부분의 빈은 디폴트 메타정보 항목이면 충분하다.
    자동인식을 통한 빈 등록을 사용하려면 두 가지 방법이 있다.
        1. XML을 이용한 빈 스캐너 등록
          XML 설정 파일에 <context:component-scan> 태그를 넣어주기만 하면 된다.
          ex) <context:component-scan base-package="springbook.learningtest.spring.ioc.bean />
        2. 빈 스캐너를 내장한 어플리케이션 컨텍스트 사용
          XML에 빈 스캐너를 지정하는 대신 아예 빈 스캐너를 내장한 컨텍스트를 사용하는 방법도 있다.
          루트 컨텍스트가 XML 대신 빈 스캐너를 이용해 빈을 등록하도록 web.xml 안에 컨텍스트 파라미터를 설정할 수 있다.
          <context-param>
            <param-name>contextClass</param-name>
            <param-value>
                org.springframework.web.context.support.AnnotationConfigWebApplicationContext
            </param-value>
          </context-param>
          <context-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>
              springbook.learningtest.springtest.spring.ioc.bean
            </param-value>
          </context-param>
4. 자바 코드에 의한 빈 등록: @Configuration 클래스의 @Bean 메서드
    자바 코드에 의한 빈 등록 방법은 코드가 빈 오브젝트를 만들고 DI 등의 초기화 작업을 한다는 면에서 팩토리 빈과 유사하다. 하지만 그보다 훨씬 편리하고 강력한 방법을 제공한다.
    클래스에 @Configuration을 선언하고 해당 클래스 내에서 @Bean 어노테이션이 붙은 메서드를 이용해 빈을 생성한다.
    @Configuration
    public class HelloConfig {
        @Bean
        public Hello hello() {
            return new Hello();
        }
    }
    스프링은 기본적으로 싱글톤 빈을 생성한다. 하지만 스프링 컨테이너 밖에서 새로운 인스턴스가 만들어진다면 이것은 싱글톤이 아니라 매번 새로운 인스턴스가 생성된다는 걸 인지해야 한다. 그래서 @Configuration, @Bean을 사용하는 클래스는 순수한 오브젝트 팩토리 클래스라기보다는 자바 코드로 표현되는 메타정보라고 이해하는 것이 좋다.

    자바 코드에 의한 설정이 XML과 같은 외부 설정파일을 이용하는 것보다 유용한 점을 살펴보자
    1. 컴파일러나 IDE를 통한 타입 검증이 가능하다.
    2. 자동완성과 같은 IDE 지원 기능을 최대한 이용할 수 있다.
    3. 이해하기 쉽다.
    4. 복잡한 빈 설정이나 초기화 작업을 손쉽게 적용할 수 있다.

5. 자바 코드에 의한 빈 등록: 일반 빈 클래스의 @Bean 메서드
    자바 코드에 의한 빈 등록은 기본적으로 @Configuration 어노테이션이 붙은 설정 전용 클래스를 사용한다.
    @Configuration이 붙지 않은 클래스에서 @Bean을 사용할 경우 다른 @Bean 메서드를 직접 호출하면 매번 다른 오브젝트를 받게 된다.
    일반 POJO 클래스에서 @Bean을 사용할 때는 DI 코드를 주의해서 작성해야 한다.
    일반 클래스에서 @Bean을 사용할 경우 이런 위험성이 있기 때문에 함부로 남용해서는 안 된다. @Bean 메서드가 정의된 클래스 밖에서 실수로라도 메서드를 호출할 수 없도록 private으로 선언해두고, 클래스 내부에서도 DI를 통해 참조해야지 메서드를 직접 호출하지 않도록 주의해야 한다.

빈 등록 메타정보 구성 전략
    자주 사용되는 설정 방법
    1. XML 단독 사용
        모든 빈을 명시적으로 XML에 등록하는 방법
        모든 설정정보를 자바 코드에서 분리하고 순수한 POJO 코드를 유지하고 싶다면 XML이 가장 좋은 선택이다.
        XML은 BeanDefinition을 코드에서 직접 만드는 방법을 제외하면 스프링이 제공하는 모든 종류의 빈 설정 메타정보 항목을 지정할 수 있는 유일한 방법이다.

    2. XML과 빈 스캐닝의 혼용
        XML과 빈 스캐너에 의한 자동인식 방법을 사용할 수도 있다.
        어플리케이션 3계층의 핵심 로직을 담고 있는 빈 클래스는 그다지 복잡한 빈 메타정보를 필요로 하지 않는다. 대부분 싱글톤이며 클래스당 하나만 만들어지므로 빈 스캐닝에 의한 자동인식 대상으로 적절하다. 반면에 자동인식 방식으로 등록하기는 불편한 기술 서비스, 기반 서비스, 컨테이너 설정 등의 빈은 XML을 사용하면 된다.
        스키마에 정의된 전용 태그를 사용해서 AOP나 트랜잭션 속성, 내장형 DB, OXM마샬러를 위한 빈을 손쉽게 등록할 수 있다.
        자동인식 방식으로 설정하기 어려운 DataSource, 트랜잭션 매니저 등은 <bean>태그를 사용해 설정할 수 있다.
        빈 스캐닝과 XML을 혼용하는 방법은 각 방법의 장점을 살려서 적용하면 매우 효과적이다.
        단 스캔 대상이 되는 클래스를 위치시킬 패키지를 미리 결정해둬야 한다는 점을 주의해야 한다.
        만약 UserService 클래스가 루트 어플리케이션 컨텍스트에 등록되어야 하는 서비스 계층의 빈이다.
        만약 UserService가 서블릿 컨텍스트에도 등록되어버렸을 때 어떻게 될까?
        컨텍스트 계층구조에서 빈을 찾을 때는 자신의 컨텍스트를 검색하고 없을 때 부모 컨텍스트를 찾는다.
        이 때 서블릿 컨텍스트에 만들어진 UserService 빈을 사용하게 된다.
        서블릿 컨텍스트에는 트랜잭션 AOP 설정이 없으므로 서블릿 컨텍스트에서 만들어진 UserService 빈에는 트랜잭션이 적용되지 않는다.
        웹 어플리케이션의 이중 컨텍스트 계층 구조와 빈 검색 우선순위를 잘 이해하고 빈 스캐닝 설정을 제공할 때 중복 등록이 발생하지 않도록 주의해야 한다.
    3. XML 없이 빈 스캐닝 단독 사용
        주요한 컨테이너 설정과 기반 서비스를 위한 설정은 모두 자바 코드에 의한 빈 설정 방식을 사용해야 한다.
        웹 어플리케이션에 적용하려면 루트 컨텍스트와 서블릿 컨텍스트 모두 contextClass 파라미터를 추가해 AnnotationConfigWebApplicationContext로 컨텍스트 클래스를 변경해줘야 한다.
        contextLocations 파라미터에는 스캔 대상 패키지를 넣어줘야 한다.
        이 방식의 장점은 모든 빈의 정보가 자바 코드에 담겨있으므로 빈의 설정정보를 타입에 안전한 방식으로 작성할 수 있다.
        하지만 스프링이 미리 제공해주는 aop, tx 등 비롯한 10여 개의 스키마와 그 안에 정의된 전용 태그를 쓸 수 없다는 단점이 있다.

빈 의존관계 설정 방법
    1. XML: <property>, <constructor-arg>
    프로퍼티와 생성자 두 가지 방식으로 DI를 지정할 수 있다.
    프로퍼티는 자바빈 규약을 따르는 수정자 메서드를 사용하고, 생성자는 빈 클래스의 생성자를 이용하는 방법이다.
    두 가지 모두 파라미터로 의존 오브젝트 또는 값을 주입해준다.
        - <property> 수정자 주입
            <bean>
                <property name="printer" ref="defaultPrinter" />
            </bean>

            <bean id="defaultPrinter" class="...">
            다음과 같이 ref 애트리뷰트를 사용하면 빈 이름을 이용해 주입할 빈을 찾는다.

            <property name="name" value="Spring"/>
            <property name="age" value="30"/>
            <property name="myClass" value="java.lang.String" />
            value 애트리뷰트로 넣을 수 있는 값의 타입에는 제한이 없다.
            다양한 종류의 클래스도 value를 이용해 주입할 수 있다.
            myClass는 String 타입의 문자열 같지만 Class 타입이다.
            수정자의 파라미터 타입을 보고 java.lang.String 문자열을 java.lang.String 클래스 오브젝트로 변환해준다.
            적절한 변환기를 컨테이너에 등록하면 어떤 오브젝트도 value 애트리뷰트의 값으로부터 생성해서 프로퍼티에 주입할 수 있다.
            XML의 <property>에는 해당 프로퍼티 타입이 나타나지 않기 때문에 값의 타입이 호환되는지 주의를 기울여서 작성해야 한다.
        - <constructor-arg> 생성자 주입
            생성자 파라미터는 파라미터의 순서나 타입을 명시하는 방법이 필요하다.
            public Hello(String name, Printer printer){
                this.name = name;
                this.printer = printer;
            }

            <bean id="hello" class="springbook.learningtest.spring.ioc.bean.Hello">
                <constructor-arg index="0" value="Spring"/>
                <constructor-arg index="1" ref="printer"/>
            </bea>

            ref, value 애트리뷰트는 <property>에서 동일한 의미라고 보면 된다.
            타입이 중복되지 않다면 아래와 같이 사용할 수 있다.
            <constructor-arg type="java.lang.String" value="Spring" />
            <constructor-arg type="springbook.learningtest.spring.ioc.bean.Printer" ref="printer" />

    2. XML: 자동와이어링
        XML 문서의 양을 대폭 줄여줄 수 있는 획기적인 방법이다. 명시적으로 프로퍼티나 생성자 파라미터를 지정하지 않고 미리 정해진 규칙을 이용해 자동으로 DI 설정을 컨테이너에 추가하는 방법이다.

        -byName: 빈 이름 자동 와이어링
        autowire="byName"에 의해 스프링은 Hello 클래스의 프로퍼티의 이름과 동일한 빈을 찾아서 자동으로 등록해준다.
        <bean id="hello" class="...Hello" autowire="byName">
            <property name="name" value="Spring />
            <property name="printer" ref="printer" /> => 생략할 수 있다.
        </bean>

        <bean id="printer class="...StringPrinter/>

        모든 빈에 적용할 것이라면 루트 태그인 <beans>의 디폴트 자도와이어링 옵션을 변경해줘도 된다.
        <beans default-autowire="byName">
            <bean>...</bean>
        </beans>

         -byType: 타입에 의한 자동와이어링
         타입에 의한 자동와이어링은 프로퍼티의 타입과 각 빈의 타입을 비교해서 자동으로 연결해주는 방법
         타입에 의한 자동와이어링은 autowire="byType"을 <bean>에 넣어주거나 default-autowire="byType"을 <beans>에 넣어주면 된다.

    3. XML: 네임스페이스와 전용 태그
        스키마를 정의해서 사용하는 전용 태그의 의존관계 지정은 단순하지 않다.
        관례적으로 전용 태그에 의해 만들어지는 빈을 다른 빈이 참조할 경우 id 애트리뷰트를 사용해 빈의 아이디를 지정한다.
        <oxm:jaxb2-marshaller id="unmarshaller" contextPath="..." />
        이 태그에 의해 몇 개의 빈이 만들어지는지는 알 수 없지만 Marshaller 인터페이스를 구현한 빈이 하나 만들어질 것이고, 그 아이디가 unmarshaller라는 것은 알 수 있다.