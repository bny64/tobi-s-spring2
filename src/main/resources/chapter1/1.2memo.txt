빈 설정 메타정보 항목
beanClassName : 빈 오브젝트 클래스 이름
parentName : 빈 메타정보를 상속받을 부모 BeanDefinition 이름
factoryBeanName: 팩토리 빈 이름
factoryMethodName : 다른 빈 또는 클래스의 메서드를 통해 빈 오브젝트를 생성하는 경우 메서드 이름
scope : 생명주기를 결정하는 스코프, 싱글톤 혹은 비싱글톤
lazyInit : 빈 오브젝트의 생성을 최대한 지연할 것인지 지정
dependsOn : 먼저 만들어져야 하는 빈을 지정할 수 있다. 빈 오브젝트의 생성 순서가 보장되어야 하는 경우 이용
autowireCandidate : 명시적인 설정이 없어도 미리 정해진 규칙을 가지고 자등올 DI 후보를 결졍하는 자동 와어어링 대상으로 포함시킬지 여부
primary : DI 대상후보가 여러 개가 발생하는 경우, 최종 선택의 우선권 부여
abstract : 메타정보 상속에만 사용할 추상 빈으로 만들지의 여부
autowireMode : 오토와이어링 전략
dependencyCheck : 프로퍼티 값 또는 레퍼런스가 모두 설정되어 있는지 검증하는 작업의 종류
initMethod : 빈이 생성되고 DI를 마친 뒤 실행할 초기화 메서드
destroyMethod : 빈의 생명주기가 다 되서 제거하기 전에 호출할 메서드
propertyValues : 프로퍼티의 이름과 설정 값 또는 레퍼런스, 수정자 메서드를 통한 DI 작업에서 사용
constructorArgumentValues : 생성자의 이름과 설정 값 또는 레퍼런스, 생성자를 통한 DI 작업에서 사용
annotationMetadata : 빈 클래스에 담긴 애노테이션과 그 애트리뷰트 값, 애노테이션을 이용하는 설정에서 활용

빈 등록 방법
1. XML <bean> 태그
    기본적으로 id와 class라는 두 개의 애트리뷰트가 필요하다.
    <bean>은 다른 빈의 <property>태그 안에 정의할 수도 있다.
    다른 빈의 설정 안에 정의되는 빈을 내부 빈(inner bean)이라고 하는데 아이디가 없으므로 다른 빈에서 참조할 수 없다.

2. 네임스페이스와 전용 태그
    pointcut과 같은 빈들은 핵심 로직을 담은 컴포넌트가 아니고 어플리케이션 컨텍스트가 활용하는 기술적인 설정 정보를 담고 있을 뿐이다.
    컨텍스트가 사용하는 설정정보를 담은 빈과 어플리케이션 3계층에 포함되는 어플리케이션 로직을 담은 빈이 동일하게 <bean>이라는 태그를 사용해서 만들어지기 때문에 구분이 잘 안되고 빈의 등록이 어떤 의도와 의미를 갖고 있는지 파악하기 어렵다.
    스프링은 이런 기술적인 설정과 기반 서비스를 빈으로 등록할 때를 위해 의미가 잘 드러나는 네임 스페이스와 태그를 가진 설정방법을 제공한다.
    <aop:pointcut id="mypointcut" expression"..."/>

3. 자동인식을 이용한 빈 등록: 스테레오타입 애노테이션과 빈 스캐너
    특정 어노테이션이 붙은 클래스를 자동으로 찾아서 빈 등록을 해주는 방식을 빈 스캐닝을 통한 자동인식 빈 등록 기능이라고 하고, 이런 스캐닝 작업을 담당하는 오브젝트를 빈 스캐너라고 한다.
    빈 스캐너에 내장된 디폴트 필터는 @Component 어노테이션 또는 @Component를 메타 어노테이션으로 가진 어노테이션이 부여된 클래스를 선택하도록 되어 있다.
    @Component를 포함해 디폴트 필터에 적용되는 어노테이션을 스프링에서 스테레오 어노테이션이라고 부른다.
    빈 스캐너는 기본적으로 클래스 이름을 빈의 ID로 사용한다. 정확히는 클래스 이름의 첫 글자만 소문자로 바꾼 것을 사용한다.
    빈의 이름을 클래스 이름과 다르게 지정해야 할 때가 있다. 이름이 같은 빈이 이미 존재하기 때문에 충돌을 피하기 위해서이거나, 좀 더 의미 있는 이름을 사용하고 싶을 때 @Component 디폴트 값을 이용해 빈 이름을 지정할 수 있다.
    빈의 개수가 많아지면 XML 문서를 보고 전체 어플리케이션의 구성을 간단히 파악하기 어렵다.
    누군가 책임을 지고 어플리케이션을 구성하는 빈과 의존관계, 설정 등을 통제하고 관리하는 데는 XML이 유리하다.
    빈 스캔에 의해 자동등록되는 빈은 XML처럼 상세한 메타정보 항목을 지정할 수 없다. 클래스당 한 개 이상의 빈을 등록할 수 없다는 제한이 있다.
    그러나 대부분의 빈은 디폴트 메타정보 항목이면 충분하다.
    자동인식을 통한 빈 등록을 사용하려면 두 가지 방법이 있다.
        1. XML을 이용한 빈 스캐너 등록
          XML 설정 파일에 <context:component-scan> 태그를 넣어주기만 하면 된다.
          ex) <context:component-scan base-package="springbook.learningtest.spring.ioc.bean />
        2. 빈 스캐너를 내장한 어플리케이션 컨텍스트 사용
          XML에 빈 스캐너를 지정하는 대신 아예 빈 스캐너를 내장한 컨텍스트를 사용하는 방법도 있다.
          루트 컨텍스트가 XML 대신 빈 스캐너를 이용해 빈을 등록하도록 web.xml 안에 컨텍스트 파라미터를 설정할 수 있다.
          <context-param>
            <param-name>contextClass</param-name>
            <param-value>
                org.springframework.web.context.support.AnnotationConfigWebApplicationContext
            </param-value>
          </context-param>
          <context-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>
              springbook.learningtest.springtest.spring.ioc.bean
            </param-value>
          </context-param>
4. 자바 코드에 의한 빈 등록: @Configuration 클래스의 @Bean 메서드
    자바 코드에 의한 빈 등록 방법은 코드가 빈 오브젝트를 만들고 DI 등의 초기화 작업을 한다는 면에서 팩토리 빈과 유사하다. 하지만 그보다 훨씬 편리하고 강력한 방법을 제공한다.
    클래스에 @Configuration을 선언하고 해당 클래스 내에서 @Bean 어노테이션이 붙은 메서드를 이용해 빈을 생성한다.
    @Configuration
    public class HelloConfig {
        @Bean
        public Hello hello() {
            return new Hello();
        }
    }
    스프링은 기본적으로 싱글톤 빈을 생성한다. 하지만 스프링 컨테이너 밖에서 새로운 인스턴스가 만들어진다면 이것은 싱글톤이 아니라 매번 새로운 인스턴스가 생성된다는 걸 인지해야 한다. 그래서 @Configuration, @Bean을 사용하는 클래스는 순수한 오브젝트 팩토리 클래스라기보다는 자바 코드로 표현되는 메타정보라고 이해하는 것이 좋다.